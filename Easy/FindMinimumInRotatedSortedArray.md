# 问题分析：
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。
# 编程实现：
```C++
class Solution {
public:
    int findMin(vector<int>& nums)
    {
        int i;
        if(nums.size()==1)
            return nums[0];
        if(nums.size()==2)
            return min(nums[0],nums[1]);
        for(i=1;i<nums.size()-1;i++)
        {
            if(nums[i-1]-nums[i]>0&&nums[i]-nums[i+1]<0)
                return nums[i];                
        }
        return min(nums[0],nums[i]);
    }
};
```
# 总结体会：
如果数组长度是1的话，直接返回这个值就ok，如果长度是2，就返回其中的最小值，大于3的情况的时候，遍历一编数组，就看当前字母是不是比前一个数字和后一个数字都小，如果是的话，那么这个数字肯定是最小数字，因为数组之前是有序的，而且只旋转了一次。如果遍历完都没有返回值的话，最小值肯定是在第一个或者最后一个了，比较他俩的大小返回即可。