# 问题分析：
在一个给定的数组nums中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。
# 编程实现：
```C++
class Solution {
public:
    int dominantIndex(vector<int>& nums)
    {
        int i,n=nums.size(),mn=0;
        int max=nums[0];
        for(i=0;i<n;i++)
        {
            if(nums[i]>max)
            {
                max=nums[i];
                mn=i;
            }
        }
        for(i=0;i<n;i++)
        {
            if (max!=nums[i]&&max<nums[i]*2) 
                return -1;
        }
        return mn;
    }
};
```
# 总结体会：
首先需要遍历一遍数组，找到数组中的最大值，并且设置一个变量记录这个最大值的索引，然后再遍历一遍数组，查看最大值是否小于某一个非最大值的2倍，如果小于的话，就返回-1，如果最大值大于每一个值的二倍，就返回之前记录的索引。一开始做的时候，总是错误的返回-1，看了半天才发现，没有考虑到第二次遍历到最大值的情况，最大值肯定小于他本身的二倍，所以第二次遍历的判断条件需要加上一项，舍弃遍历到最大值时的情况。