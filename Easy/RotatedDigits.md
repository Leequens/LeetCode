# 问题分析：
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？
# 编程实现：
```C++
class Solution {
public:
    int rotatedDigits(int N)
    {
        int count=0;
        for(int i=1;i<=N;i++)
        {
            if(judge(i))
                count++;
        }
        return count;       
    }
    bool judge(int x)
    {
        string chars=to_string(x);
        bool res=0;
        for(char c: chars)
        {
            if(c=='3'||c=='4'||c=='7')
                return 0;
            if(c=='2'||c=='5'||c=='6'||c=='9')
                res=1;      
        }
        return res;
    }
};
```
# 总结体会：
题目中首先定义了一个好数，就是说旋转之后和原数不相同的数，所以，含有3 4 7的数肯定不是好数，仅仅含有1 0的数也不是好数。总结来说就是好数中不得含有3 5 7并且至少包含2 5 6 9中的一个数。定义一个子函数来判断是否为好数，将整数转换为字符串来查看每一位数，如果含有 3 5 7中的任何一个数，则返回false。在主函数中调用子函数即可计算出1到N之间好数的个数来。